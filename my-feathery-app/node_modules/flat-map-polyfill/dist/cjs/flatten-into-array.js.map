{"version":3,"sources":["../../src/flatten-into-array.js"],"names":["flattenIntoArray","target","source","start","depth","mapperFunction","thisArg","mapperFunctionProvied","undefined","targetIndex","sourceIndex","sourceLen","length","p","exists","element","call","spreadable","Object","getOwnPropertySymbols","includes","Symbol","isConcatSpreadable","Array","isArray","nextIndex","Number","isSafeInteger","TypeError"],"mappings":";;;;;kBAUwBA,gB;AAVxB;;;;;;;;;;AAUe,SAASA,gBAAT,CAA0BC,MAA1B,EAAkCC,MAAlC,EAA0CC,KAA1C,EAAiDC,KAAjD,EAAwDC,cAAxD,EAAwEC,OAAxE,EAAiF;;AAE9F,MAAMC,wBAAwBF,mBAAmBG,SAAjD;AACA,MAAIC,cAAcN,KAAlB;AACA,MAAIO,cAAc,CAAlB;AACA,MAAMC,YAAYT,OAAOU,MAAzB;AACA,SAAOF,cAAcC,SAArB,EAAgC;AAC9B,QAAME,IAAIH,WAAV;AACA,QAAMI,SAAS,CAAC,CAACZ,OAAOW,CAAP,CAAjB;AACA,QAAIC,WAAW,IAAf,EAAqB;AACnB,UAAIC,UAAUb,OAAOW,CAAP,CAAd;AACA,UAAIE,OAAJ,EAAa;AACX,YAAIR,qBAAJ,EAA2B;AACzBQ,oBAAUV,eAAeW,IAAf,CAAoBV,OAApB,EAA6BS,OAA7B,EAAsCL,WAAtC,EAAmDT,MAAnD,CAAV;AACD;AACD,YAAMgB,aAAaC,OAAOC,qBAAP,CAA6BJ,OAA7B,EAAsCK,QAAtC,CAA+CC,OAAOC,kBAAtD,KAA6EC,MAAMC,OAAN,CAAcT,OAAd,CAAhG;AACA,YAAIE,eAAe,IAAf,IAAuBb,QAAQ,CAAnC,EAAsC;AACpC,cAAMqB,YAAYzB,iBAAiBC,MAAjB,EAAyBc,OAAzB,EAAkCN,WAAlC,EAA+CL,QAAQ,CAAvD,CAAlB;AACAK,wBAAcgB,SAAd;AACD,SAHD,MAGO;AACL,cAAI,CAACC,OAAOC,aAAP,CAAqBlB,WAArB,CAAL,EAAwC;AACtC,kBAAMmB,WAAN;AACD;AACD3B,iBAAOQ,WAAP,IAAsBM,OAAtB;AACD;AACF;AACF;AACDN,mBAAe,CAAf;AACAC,mBAAe,CAAf;AACD;AACD,SAAOD,WAAP;AACD","file":"flatten-into-array.js","sourcesContent":["/**\r\n * @template T, U\r\n * @param {Array<U>} target\r\n * @param {Array<T>} source\r\n * @param {number} start\r\n * @param {number} depth\r\n * @param {function(T): U[]} mapperFunction\r\n * @param {Array<T>} thisArg\r\n * @returns {number}\r\n */\r\nexport default function flattenIntoArray(target, source, start, depth, mapperFunction, thisArg) {\r\n\r\n  const mapperFunctionProvied = mapperFunction !== undefined;\r\n  let targetIndex = start;\r\n  let sourceIndex = 0;\r\n  const sourceLen = source.length;\r\n  while (sourceIndex < sourceLen) {\r\n    const p = sourceIndex;\r\n    const exists = !!source[p];\r\n    if (exists === true) {\r\n      let element = source[p];\r\n      if (element) {\r\n        if (mapperFunctionProvied) {\r\n          element = mapperFunction.call(thisArg, element, sourceIndex, target);\r\n        }\r\n        const spreadable = Object.getOwnPropertySymbols(element).includes(Symbol.isConcatSpreadable) || Array.isArray(element);\r\n        if (spreadable === true && depth > 0) {\r\n          const nextIndex = flattenIntoArray(target, element, targetIndex, depth - 1);\r\n          targetIndex = nextIndex;\r\n        } else {\r\n          if (!Number.isSafeInteger(targetIndex)) {\r\n            throw TypeError();\r\n          }\r\n          target[targetIndex] = element;\r\n        }\r\n      }\r\n    }\r\n    targetIndex += 1;\r\n    sourceIndex += 1;\r\n  }\r\n  return targetIndex;\r\n}\r\n"]}