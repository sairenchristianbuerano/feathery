import type FeatheryClient from './featheryClient';
export interface RequestOptions {
    headers?: {
        'Content-Type'?: string | undefined;
        Authorization?: string;
    };
    method: string;
    body: any;
    keepalive?: boolean;
}
export declare const untrackUnload: (force?: boolean) => void;
export declare function useOfflineRequestHandler(client: FeatheryClient): void;
/**
 * OfflineRequestHandler manages HTTP request reliability for forms.
 * Failed requests are queued in IndexedDB and replayed when connectivity is restored.
 *
 * Behavior:
 * - When online: attempts requests immediately, but queues them if network errors occur
 * - When offline: immediately queues all requests for later replay
 * - Prevent page unload while requests are pending
 * - Replays requests in chronological order
 */
export declare class OfflineRequestHandler {
    private isReplayingRequests;
    private readonly formKey;
    private readonly dbName;
    private readonly storeName;
    private readonly dbVersion;
    private readonly maxRetryAttempts;
    private readonly retryDelayMs;
    private onlineSignals;
    private indexedDBSupported;
    private errorCallback?;
    constructor(formKey: string, errorCallback?: (error: string) => void);
    dbHasRequest(): Promise<boolean>;
    onlineAndReplayed(): Promise<unknown>;
    openDatabase(): Promise<IDBDatabase | undefined>;
    private getDbTransaction;
    /**
     * Core request orchestration method that decides whether to execute a request immediately
     * or queue it for later replay. This implements the "eventual consistency" pattern for
     * offline-first applications.
     *
     * Logic flow:
     * 1. If online AND no pending requests: execute immediately
     * 2. If online BUT requests are queued/replaying: wait for queue to clear, then execute
     * 3. If request fails with network error: queue it and start replay process
     * 4. If offline: immediately queue the request
     */
    runOrSaveRequest(run: any, url: string, options: any, type: string, stepKey?: string): Promise<void>;
    saveRequest(url: string, options: any, type: string, stepKey?: string): Promise<void>;
    private serializeRequestBody;
    /**
     * Replay queued requests:
     *
     * Step 1: Submit requests (form submissions, custom requests) - executed in parallel
     * Step 2: Event registrations - grouped by step and executed sequentially by step,
     *          but in parallel within each step to maintain event ordering per form step
     */
    replayRequests(): Promise<void>;
    private replayRequestsInParallel;
    private removeRequest;
    /**
     * Calculates exponential backoff delay with jitter.
     * Pattern: 1s, 2s, 4s, etc.
     */
    private getExponentialDelay;
    private delay;
    private reconstructBody;
}
//# sourceMappingURL=offlineRequestHandler.d.ts.map