import { ActionData } from '../utils';
import Cart from './Cart';
import BigDecimal from 'js-big-decimal';
export declare const getStripe: () => Promise<unknown>;
export declare function installStripe(stripeConfig: any): Promise<void>;
export declare function getFlatStripeCustomerFieldValues(stripeConfig: any): Record<string, any>;
export declare const FEATHERY_CART = "feathery.cart";
export declare const FEATHERY_CART_TOTAL = "feathery.cart.total";
export declare function getPaymentsReservedFieldValues(): Record<string, any>;
/**
 * Used to set up a payment method.
 */
export declare function setupPaymentMethod({ pmField, client, formattedFields, updateFieldValues, integrationData, targetElement }: ActionData, syncFields?: boolean, stripePromise?: null): Promise<{
    errorField: any;
    errorMessage: any;
} | null>;
interface PaymentAction {
    product_id: string;
    quantity_field?: string;
    fixed_quantity?: number;
    toggle?: boolean;
    add_to_quantity?: boolean;
    clear_cart: boolean;
    success_url?: string;
    cancel_url?: string;
}
/**
 * Determines if a product is in the cart selections with a quantity greater than 0
 * @param productId
 * @returns
 */
export declare function isProductInPurchaseSelections(productId: string): boolean | 0;
interface PricingTier {
    up_to: number | null;
    unit_amount?: number;
    flat_amount?: number;
}
declare type PRICE_TYPE = 'one_time' | 'recurring';
export interface Price {
    id: string;
    currency?: string;
    type: PRICE_TYPE;
    recurring_interval?: 'month' | 'year' | 'week' | 'day' | null | '';
    recurring_usage_type?: 'licensed' | 'metered';
    billing_scheme: 'per_unit' | 'tiered';
    unit_amount?: number;
    per_unit_units?: number;
    per_unit_rounding?: 'up' | 'down';
    tiers_mode?: 'graduated' | 'volume';
    tiers?: PricingTier[];
}
export interface Product {
    id: string;
    name: string;
    description: string;
    active: boolean;
    default_price: string;
    prices: Price[];
}
export interface ProductPriceCacheConfig {
    product_price_cache: Record<string, Product>;
}
export interface StripeConfig {
    metadata: {
        test?: ProductPriceCacheConfig;
        live?: ProductPriceCacheConfig;
    };
}
export declare function getCart(stripeConfig: StripeConfig, updateFieldValues: any, client: any): Cart;
export declare function getSimplifiedProducts(stripeConfig: StripeConfig, updateFieldValues: any, client: any): Record<string, any>;
export declare function getLiveOrTestProduct(productId: string, stripeConfig: StripeConfig): string;
/**
 * Add to cart function
 * If add_to_quantity is false, then the quantity is replaced with the new quantity,
 * otherwise the new quantity is added to the existing quantity.
 */
export declare function addToCart(paymentAction: PaymentAction, updateFieldValues: any, stripeConfig: StripeConfig, client: any): Record<string, number> | null;
/**
 * Remove from cart function.
 * Clear the cart completely if clear_cart is true.
 */
export declare function removeFromCart(paymentAction: PaymentAction, updateFieldValues: any, stripeConfig: any, client: any): Record<string, number> | null;
/**
 * Used to either collect payment directly or launch stripe checkout to collect payment.
 */
export declare function purchaseCart(actionData: ActionData, stripePromise?: null): Promise<{
    errorField: any;
    errorMessage: any;
} | null>;
export declare function checkForPaymentCheckoutCompletion(steps: any, client: any, updateFieldValues: (fieldValues: any, options?: any) => void, integrationData: any): Promise<void>;
export declare function usePayments(): [
    (key: string) => any,
    (key: string, cardElement: any) => void
];
export declare function calculateSelectedProductsTotal(stripeConfig: StripeConfig, updateFieldValues: (fv: Record<string, any>) => void, client: any): string;
export declare function calculateLineItemCost(product: Product | undefined, quantity: number, inMajorUnits?: boolean): BigDecimal;
export {};
//# sourceMappingURL=stripe.d.ts.map